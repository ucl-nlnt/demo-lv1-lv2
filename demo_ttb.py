# Mostly Copy-pasted from capstone.py

import rclpy
import time
import threading
import math
import json

from rclpy.node import Node
from nav_msgs.msg import Odometry
from rclpy.qos import qos_profile_sensor_data
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from sensor_msgs.msg import LaserScan
import numpy as np
from copy import deepcopy
#from prompt_randomizer import prompt_randomizer
from knetworking import DataBridgeClient_TCP, DataBridgeServer_TCP
import argparse
import ast
import zlib
import uuid
import os
import time
import sys
import quart_funcs

parser = argparse.ArgumentParser()

parser.add_argument("--ip", type=str, default="localhost")
parser.add_argument("--port", type=int, default=50000) # change this if you wanna use a real and simulated turtlebot at the same time
parser.add_argument("--sampling_hz", type=int, default=20)
parser.add_argument("--max_linear_x", type=float, default=0.2)
parser.add_argument("--max_angular_z", type=float, default=1.75)
parser.add_argument("--threshold_linear", type=float, default=0.01)
parser.add_argument("--threshold_angular", type=float, default=0.01)
parser.add_argument("--samples", type=int, default=1000)
parser.add_argument("--debug", type=int, default=0)
parser.add_argument("--comm", type=int, default=1)
parser.add_argument("--sampler", type=int, default=1)
parser.add_argument("--name", help="username")

args = parser.parse_args()
print(args)

if not os.path.exists("datalogs_auto"):
    os.mkdir("datalogs_auto")

def compute_distance(coord1: list, coord2: list):

    total = 0
    for i in range(3):
        total += (coord2[i] - coord1[i])**2
    
    return math.sqrt(total)


def quaternion_to_yaw(x, y, z, w): # Generated by GPT-4

    """
    Convert a quaternion into yaw (rotation around z-axis in radians)
    """
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw_z = math.atan2(t3, t4)
    return yaw_z

def yaw_difference(quaternion1, quaternion2): # Generated by GPT-4
    """
    Calculate the difference in yaw between two quaternions
    """
    yaw1 = quaternion_to_yaw(*quaternion1)
    yaw2 = quaternion_to_yaw(*quaternion2)
    
    # Calculate the difference and adjust for the circular nature of angles
    difference = yaw2 - yaw1
    difference = (difference + math.pi) % (2 * math.pi) - math.pi
    
    return difference

def normalize_radians(float_num):
    return (float_num + np.pi) % (2 * np.pi) - np.pi

def generate_random_filename():

    random_filename = str(uuid.uuid4().hex)[:16]
    return random_filename

class AutoDataCollector(Node):

    def __init__(self, comm_on = True, sampler_on = True, debug = False):

        super().__init__('ttb_demo')
        self.movement_publisher = self.create_publisher(Twist, '/cmd_vel',10)
        self.create_subscription(LaserScan, 'scan', self.laserscan_callback, qos_profile_sensor_data)
        self.create_subscription(Odometry, 'odom', self.odometer_callback, qos_profile_sensor_data)  
        self.create_subscription(Twist,'cmd_vel', self.twist_callback, qos_profile_sensor_data)
        self.create_subscription(Imu,'imu', self.imu_callback, qos_profile_sensor_data) # IMU data doesn't seem to be useful currently // Gab

        self.starting_odometry_set = False
        # class-wide variables to be used
        self.direction = None
        self.distance_traveled = 0.0
        self.radians_rotated = 0.0
        self.odometry_msg_data = (None, None, None, None)
        self.odometry_msg_data_pos = (None, None, None)
        self.odometry_msg = None

        self.client = DataBridgeClient_TCP(destination_ip_address=args.ip, destination_port=50000)
        time.sleep(1) # allow server to open port 15000
        self.json_transmitter = DataBridgeClient_TCP(destination_ip_address=args.ip,destination_port=15000)

        self.twist_timestamp = None
        self.last_twist_timestamp = None
        self.collect_data = True
        self.data_frame_buffer = []
        self.laserscan_msg = None

        # data messages init
        self.super_json = None
        self.sampling_rate_hz = args.sampling_hz
        self.imu_msg = None
        self.twist_msg = None
        self.sampling_start = False
        self.linear_x = 0.0
        self.angular_z = 0.0

        self.front_is_blocked = False

        # multithreading stuff
        self.transmitter = threading.Thread(target=self.sampling_process) # sends data to controller
        self.transmitter.daemon = True
        self.transmitter.start()

        if comm_on:
        
            self.controller = threading.Thread(target=self.communicator)      # receives instructions from controller
            self.controller.daemon = True
            self.controller.start()

        # super json transmitter
        self.super_json_broadcaster = threading.Thread(target=self.json_uplink)
        self.super_json_broadcaster.start()

        # soft barrier checker
        self.barrier_thread = threading.Thread(target=self.soft_barrier)
        self.barrier_thread.start()

        # asynchronously handles movement
        self.movement_handler_thread = threading.Thread(target=self.movement_server)
        self.movement_handler_thread.start()

    def json_uplink(self):

        while self.super_json == None:
            print("Waiting for super json...")
            time.sleep(1)

        wait_time = 1/args.sampling_hz * 0.5 # super json nyquist frequency

        while True:
            
            if self.super_json == None: # wait until new super json is available
                time.sleep(wait_time)

            data = str(self.super_json).encode("utf-8")
            self.json_transmitter.send_data(data)
            self.super_json = None # set as none to prevent sending duplicates

    def laserscan_callback(self, msg):
        if msg == None: return
        self.laserscan_msg = msg

    def twist_callback(self,msg):
        if msg == None: return
        self.twist_msg = msg

    def imu_callback(self,msg):

        if msg == None: return
        self.imu_msg = msg

    def sampling_process(self):
        
        # wait for the msgs to reead
        while self.imu_msg == None: 
            print("waiting for imu msg...")
            time.sleep(0.1)
        while self.odometry_msg_data == None:
            print("waiting for odetry msg data...")
            time.sleep(0.1)
        while self.odometry_msg_data_pos == None: 
            print("waiting for odometry pos...")
            time.sleep(0.1)
        while self.odometry_msg == None: 
            print("waiting for odometry msg...")
            time.sleep(0.1)

        twist_msg_jsonized = { # default
                    "linear":(0.0, 0.0, 0.0),
                    "angular":(0.0, 0.0, 0.0),
                    "time":self.twist_msg
                }
    
        self.sampling_start = True # unlocks data collection to ensure that there is data from the sensors
        while True:
           
            if not self.collect_data:
                time.sleep(0.05) # wait until unlocked
                continue

            imu_msg_jsonized = {
                "quarternion_orientation": (self.imu_msg.orientation.x, self.imu_msg.orientation.y, self.imu_msg.orientation.z, self.imu_msg.orientation.w),
                "orientation_covariance": [i for i in self.imu_msg.orientation_covariance],
                "angular_velocity": (self.imu_msg.angular_velocity.x, self.imu_msg.angular_velocity.y, self.imu_msg.angular_velocity.z),
                "angular_velocity_covariance": [i for i in self.imu_msg.angular_velocity_covariance],
                "linear_acceleration": (self.imu_msg.linear_acceleration.x, self.imu_msg.linear_acceleration.y, self.imu_msg.linear_acceleration.z),
                "linear_acceleration_covariance": [i for i in self.imu_msg.linear_acceleration_covariance]
            }
            
            msg_pose = self.odometry_msg.pose.pose
            position, orientation = msg_pose.position, msg_pose.orientation
            msg_pose_covariance = self.odometry_msg.pose.covariance
            
            odometry_msg_jsonized = {
                "time_sec":self.odometry_msg.header.stamp.sec,
                "time_nano":self.odometry_msg.header.stamp.nanosec,
                "pose_position":(position.x, position.y, position.z),
                "pose_orientation_quarternion":(orientation.x, orientation.y, orientation.z, orientation.w),
                "object_covariance":[i for i in msg_pose_covariance]
            }

            if self.twist_msg != None:
                twist_msg_jsonized = {
                    "linear":(self.twist_msg.linear.x, self.twist_msg.linear.y, self.twist_msg.linear.z),
                    "angular":(self.twist_msg.angular.x, self.twist_msg.angular.y, self.twist_msg.angular.z),
                    "time":self.twist_timestamp
                }

            # if need laser scan data, will add in the future
            
            self.super_json = { 
            "laser_scan" : None, "twist":twist_msg_jsonized, "imu":imu_msg_jsonized, 
            "odometry":odometry_msg_jsonized, "battery":None, "frame_data":None, "distance_traveled":self.distance_traveled, "radians_rotated":self.radians_rotated
            }

            time.sleep(1/args.sampling_hz)
            
    def communicator(self):
        
        precision = 3
        while self.odometry_msg == None: print('waiting for odometry msg'); time.sleep(0.1)
        while self.odometry_msg_data == None: print('waiting for odometry msg data'); time.sleep(0.1)

        while True:
            
            # initialize here
            starting_odometry = self.odometry_msg_data
            normalizing_quat = quart_funcs.inverse_quarternion(starting_odometry)
            lock = self.client.receive_data().decode()

            if lock != 'START':
                continue
            
            self.direction = None

            total_instruction_distance = 0.0
            total_rotation_angular_distance = 0.0

            while True:

                # [linear x: float, angular z: float, delta t: float, complete: bool or int]
                ins_start_pos = self.odometry_msg_data_pos
                print('==============')
                
                instruction = self.client.receive_data().decode().strip()
                print('received:', instruction)
                data = ast.literal_eval(instruction) # instructions
                
                x, z, dt, is_complete = data
                t = time.time()
                if x > 0.2: x = 0.2

                ins_start_orientation = quart_funcs.adjust_orientation_origin(normalizing_quat,self.odometry_msg_data)
                
                last_direction = None
                if z == 0.0:

                    self.direction = 'forward'
                    last_direction = 'forward'
                    self.linear_x = x

                if x == 0.0:

                    self.direction = 'left' if z > 0.0 else 'right'
                    last_direction = 'left' if z > 0.0 else 'right'
                    self.angular_z = z
                    
                time.sleep(dt)
                print('Delta t done.', dt, round(time.time() - t,3))
                self.direction = None

                time.sleep(0.5) # allow for deceleration

                distance = compute_distance(self.odometry_msg_data_pos, ins_start_pos)
                ins_end_orientation = quart_funcs.adjust_orientation_origin(normalizing_quat,self.odometry_msg_data)
                print("Blocked:",self.front_is_blocked, '|',self.direction)
                
                return_data = str(

                    {
                        'orientation': round(quaternion_to_yaw(*ins_end_orientation),precision),
                        'distance_traveled': round(distance,precision),
                        'blocked' : 1 if self.front_is_blocked and last_direction == 'forward' else 0
                    }

                )
                
                delta_yaw = yaw_difference(quaternion1=ins_start_orientation, quaternion2=ins_end_orientation)
                total_instruction_distance += distance
                total_rotation_angular_distance += delta_yaw
                print('Current iteration distance:', round(distance,3), "meters.")
                print(f'Current iteration angular distance: {round(delta_yaw / math.pi * 180,3)} degrees | {round(delta_yaw,3)} radians.') 
                print('Total distance traveled:', round(total_instruction_distance,3))
                print(f'Total orientation difference: {round(total_rotation_angular_distance / math.pi * 180,3)} degrees | {round(total_rotation_angular_distance,3)} radians.')
                print('return data:', return_data)
                print('\n')
                self.client.send_data(return_data.encode())
                if is_complete: print('##########################################################################################'); break

    def soft_barrier(self):

        while self.laserscan_msg == None: time.sleep(0.1) # wait for lidar scanner to wake up

        max_value = self.laserscan_msg.range_max
        min_value = self.laserscan_msg.range_min

        while True:

            scans = deepcopy(self.laserscan_msg.ranges) # prevent race conditions
            
            # i = degree
            # val = depth or distance
            
            for i, val in enumerate(scans): # clip too small and too large values

                if (i > 45 and i < 314): 
                    continue 
                
                if (val < min_value and val != 0.0):
                    scans[i] = min_value

                if (val > max_value): 
                    scans[i] = max_value

            degrees_blocked = 0
#            print('==========================')

            for i, val in enumerate(scans):

                if (i > 45 and i < 314): 
                    continue 

                if val < 0.3 and val != 0.0:

                    degrees_blocked += 1
#                    print(i, val)

                    if degrees_blocked >= 5:

                        self.front_is_blocked = True
                        break # no need to iterate through other values

            if degrees_blocked < 5:
                self.front_is_blocked = False

            time.sleep(0.09) # slightly faster than nyquist frequency of lidar, which runs at a period of t = 0.2 seconds


    def reset_distance_and_radians(self):

        self.distance_traveled = 0.0
        self.radians_rotated = 0.0

    def odometer_callback(self,msg):

        if msg == None: return
        
        if not self.starting_odometry_set: 
            self.starting_odometry_set = True
        
        self.odometry_msg = msg
        self.odometry_msg_data = (
            msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w,
        )
        self.odometry_msg_data_pos = (
            msg.pose.pose.position.x,
            msg.pose.pose.position.y,
            msg.pose.pose.position.z
        )

    def print_log(self, mess:str):

        print(f"[AutoDataCollector: {time.ctime()}] " + mess)

    
    def movement_server(self):

        data = Twist()
        while True:

            if self.direction == None:
                time.sleep(0.05)
                continue

            elif self.direction == 'forward':

                if self.front_is_blocked:

                    print('Cannot move forward! Front is blocked.')
                    time.sleep(0.5)
                    continue

                starting_odometry = self.odometry_msg_data
                correctionary_angular_z = 0.0
                max_angular_z = 1.2

                while self.direction == 'forward':

                    yaw_diff = yaw_difference(quaternion2=self.odometry_msg_data, quaternion1=starting_odometry)
                    correctionary_angular_z = -yaw_diff / 0.1
                    correctionary_angular_z = max(-max_angular_z, min(max_angular_z, correctionary_angular_z))
                    data.linear.x = self.linear_x
                    data.angular.z = correctionary_angular_z

                    if self.front_is_blocked:
                        
                        print("Cannot move forward! Front is blocked.")
                        break
                    
                    self.movement_publisher.publish(data)
                    time.sleep(0.01)

                data.linear.x = 0.0
                data.angular.z = 0.0
                self.movement_publisher.publish(data) # deceleration

            elif self.direction == 'left' or self.direction == 'right':

                data.linear.x = 0.0
                while self.direction == 'left' or self.direction == 'right':

                    data.angular.z = self.angular_z
                    self.movement_publisher.publish(data)
                    time.sleep(0.1)

                data.linear.x = 0.0
                data.angular.z = 0.0
                self.movement_publisher.publish(data) # deceleration

    """ # Legacy code
    def __publish_twist_message(self, linear_x, angular_z):


        data = Twist()
        data.linear.x = linear_x
        data.angular.z = angular_z
        self.movement_publisher.publish(data)
        
        self.twist_timestamp = time.time()
        self.last_twist_timestamp = self.twist_timestamp

        return

    def move_x_meters_feedback(self, distance, slowdown_threshold=0.4, vel_x:float = 0.2): # accurate, works up to +- 0.005 meters

        # implement here
        start = self.odometry_msg_data_pos
        self.distance_traveled = 0.0
        switch = True

        while distance - slowdown_threshold > self.distance_traveled:
            if switch:
                self.__publish_twist_message(vel_x,0.0)
                switch = False
        

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5)

        switch = True
        while distance > self.distance_traveled:
            if switch:
                self.__publish_twist_message(0.1,0.0)
                switch = False

        self.__publish_twist_message(0.0,0.0)
        
        time.sleep(0.5)
        end = self.odometry_msg_data_pos
        print("Distance error:",round(distance-compute_distance(start, end), 4))

        return distance-compute_distance(start, end)

    def rotate(self, angular_distance_radians, direction, slowdown_threshold = 0.4, angl_vel_z:float = 1.0):

        print("Direction:", direction)
        self.radians_rotated = 0.0
        starting = self.odometry_msg_data

        switch = True # this is done to get the min and max angular values
        while angular_distance_radians-slowdown_threshold > self.radians_rotated:

            if direction.lower() == "left":
                
                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=angl_vel_z)
            elif direction.lower() == "right":
                
                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=-angl_vel_z)
            else:
                print("ERROR: invalid direction")
                return
            time.sleep(0.1)

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5) # simulate inference

        switch = True
        while angular_distance_radians > self.radians_rotated:

            if direction.lower() == "left":

                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=0.2)
            elif direction.lower() == "right":

                if switch:
                    switch = False
                    self.__publish_twist_message(0.0,angular_z=-0.2)
            else:
                print("ERROR: invalid direction")
                return
            time.sleep(0.1)

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5)

        ending = self.odometry_msg_data
        
        print(f"Rotated {direction} degrees [Internal]:",round(self.radians_rotated * 180 / math.pi,3))
        return round(self.radians_rotated * 180 / math.pi,3)
    
    def rotate_to_orientation(self, angle_in_radians: float, angl_vel_z: float = 1.5):
        
        desired = normalize_radians(angle_in_radians) # prevent unattainable cases
        current = normalize_radians(quaternion_to_yaw(*self.odometry_msg_data))

        delta = desired - current

        if math.isclose(delta,0,rel_tol=args.threshold_angular):
            return 
        
        elif delta > 0: # rotate left
    
            self.rotate(abs(delta), "left")

        else: # delta < 0

            self.rotate(abs(delta), "right")
    """

def main(args=None, n_args=args):

    rclpy.init(args=args)

    sensors_subscriber = AutoDataCollector(comm_on=n_args.comm, sampler_on=n_args.sampler, debug=n_args.debug)
    rclpy.spin(sensors_subscriber)
    sensors_subscriber.destroy_node()

if __name__ == '__main__':

    main()