# Mostly Copy-pasted from capstone.py

import rclpy
import time
import threading
import math
import json

from rclpy.node import Node
from nav_msgs.msg import Odometry
from rclpy.qos import qos_profile_sensor_data
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
import numpy as np
from copy import deepcopy
#from prompt_randomizer import prompt_randomizer
from knetworking import DataBridgeClient_TCP, DataBridgeServer_TCP
import argparse
import ast
import zlib
import uuid
import os
import time
import sys
import quart_funcs

parser = argparse.ArgumentParser()

parser.add_argument("--ip", type=str, default="localhost")
parser.add_argument("--port", type=int, default=50000) # change this if you wanna use a real and simulated turtlebot at the same time
parser.add_argument("--sampling_hz", type=int, default=20)
parser.add_argument("--max_linear_x", type=float, default=0.2)
parser.add_argument("--max_angular_z", type=float, default=1.75)
parser.add_argument("--threshold_linear", type=float, default=0.01)
parser.add_argument("--threshold_angular", type=float, default=0.01)
parser.add_argument("--samples", type=int, default=1000)
parser.add_argument("--debug", type=int, default=0)
parser.add_argument("--comm", type=int, default=1)
parser.add_argument("--sampler", type=int, default=1)
parser.add_argument("--name", help="username")

args = parser.parse_args()
print(args)

if not os.path.exists("datalogs_auto"):
    os.mkdir("datalogs_auto")

def compute_distance(coord1: list, coord2: list):

    total = 0
    for i in range(3):
        total += (coord2[i] - coord1[i])**2
    
    return math.sqrt(total)


def quaternion_to_yaw(x, y, z, w): # Generated by GPT-4

    """
    Convert a quaternion into yaw (rotation around z-axis in radians)
    """
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw_z = math.atan2(t3, t4)
    return yaw_z

def yaw_difference(quaternion1, quaternion2): # Generated by GPT-4
    """
    Calculate the difference in yaw between two quaternions
    """
    yaw1 = quaternion_to_yaw(*quaternion1)
    yaw2 = quaternion_to_yaw(*quaternion2)
    
    # Calculate the difference and adjust for the circular nature of angles
    difference = yaw2 - yaw1
    difference = (difference + math.pi) % (2 * math.pi) - math.pi
    
    return difference

def normalize_radians(float_num):
    return (float_num + np.pi) % (2 * np.pi) - np.pi

def generate_random_filename():

    random_filename = str(uuid.uuid4().hex)[:16]
    return random_filename

class AutoDataCollector(Node):

    def __init__(self, comm_on = True, sampler_on = True, debug = False):

        super().__init__('AutoDataCollector_lv1_lv2')

        if args.name == None:
            self.user = input("Enter your name for logging purposes: ")
        else:
            self.user = args.name

        self.movement_publisher = self.create_publisher(Twist, '/cmd_vel',10)
        self.create_subscription(Odometry, 'odom', self.odometer_callback, qos_profile_sensor_data)  
        self.create_subscription(Twist,'cmd_vel', self.twist_callback, qos_profile_sensor_data)
        self.create_subscription(Imu,'imu', self.imu_callback, qos_profile_sensor_data) # IMU data doesn't seem to be useful currently // Gab

        self.starting_odometry_set = False
        # class-wide variables to be used
        self.distance_traveled = 0.0
        self.radians_rotated = 0.0
        self.odometry_msg_data = (None, None, None, None)
        self.odometry_msg_data_pos = (None, None, None)
        self.odometry_msg = None

        self.client = DataBridgeClient_TCP(destination_ip_address='localhost', destination_port=50000)

        self.twist_timestamp = None
        self.last_twist_timestamp = None
        self.collect_data = False
        self.data_frame_buffer = []

        # data messages init
        self.super_json = None
        self.sampling_rate_hz = args.sampling_hz
        self.imu_msg = None
        self.twist_msg = None
        self.sampling_start = False

        # multithreading stuff
        if sampler_on:
        
            self.transmitter = threading.Thread(target=self.sampling_process) # sends data to controller
            self.transmitter.daemon = True
            self.transmitter.start()

        if comm_on:
        
            self.controller = threading.Thread(target=self.communicator)      # receives instructions from controller
            self.controller.daemon = True
            self.controller.start()

    def twist_callback(self,msg):
        if msg == None: return
        self.twist_msg = msg

    def imu_callback(self,msg):

        if msg == None: return
        self.imu_msg = msg

    def sampling_process(self):
        
        # wait for the msgs to reead
        while self.imu_msg == None: time.sleep(0.1)
        while self.odometry_msg_data == None: time.sleep(0.1)
        while self.odometry_msg_data_pos == None: time.sleep(0.1)
        while self.odometry_msg == None: time.sleep(0.1)
        
        self.__publish_twist_message(0.0, 0.0)

        twist_msg_jsonized = { # default
                    "linear":(0.0, 0.0, 0.0),
                    "angular":(0.0, 0.0, 0.0),
                    "time":self.twist_msg
                }
        
        self.sampling_start = True # unlocks data collection to ensure that there is data from the sensors
        while True:
           
            if not self.collect_data:
                time.sleep(0.05) # wait until unlocked
                continue

            imu_msg_jsonized = {
                "quarternion_orientation": (self.imu_msg.orientation.x, self.imu_msg.orientation.y, self.imu_msg.orientation.z, self.imu_msg.orientation.w),
                "orientation_covariance": [i for i in self.imu_msg.orientation_covariance],
                "angular_velocity": (self.imu_msg.angular_velocity.x, self.imu_msg.angular_velocity.y, self.imu_msg.angular_velocity.z),
                "angular_velocity_covariance": [i for i in self.imu_msg.angular_velocity_covariance],
                "linear_acceleration": (self.imu_msg.linear_acceleration.x, self.imu_msg.linear_acceleration.y, self.imu_msg.linear_acceleration.z),
                "linear_acceleration_covariance": [i for i in self.imu_msg.linear_acceleration_covariance]
            }
            
            msg_pose = self.odometry_msg.pose.pose
            position, orientation = msg_pose.position, msg_pose.orientation
            msg_pose_covariance = self.odometry_msg.pose.covariance
            
            odometry_msg_jsonized = {
                "time_sec":self.odometry_msg.header.stamp.sec,
                "time_nano":self.odometry_msg.header.stamp.nanosec,
                "pose_position":(position.x, position.y, position.z),
                "pose_orientation_quarternion":(orientation.x, orientation.y, orientation.z, orientation.w),
                "object_covariance":[i for i in msg_pose_covariance]
            }

            if self.twist_msg != None:
                twist_msg_jsonized = {
                    "linear":(self.twist_msg.linear.x, self.twist_msg.linear.y, self.twist_msg.linear.z),
                    "angular":(self.twist_msg.angular.x, self.twist_msg.angular.y, self.twist_msg.angular.z),
                    "time":self.twist_timestamp
                }

            # if need laser scan data, will add in the future
            
            self.super_json = { 
            "laser_scan" : None, "twist":twist_msg_jsonized, "imu":imu_msg_jsonized, 
            "odometry":odometry_msg_jsonized, "battery":None, "frame_data":None, "distance_traveled":self.distance_traveled, "radians_rotated":self.radians_rotated
            }
            
            self.data_frame_buffer.append(self.super_json)
            time.sleep(1/args.sampling_hz)
            
    def communicator(self):
        
        precision = 3
        while self.odometry_msg == None: time.sleep(0.1)

        while True:
            
            # initialize here
            starting_odometry = self.odometry_msg_data
            normalizing_quat = quart_funcs.inverse_quarternion(starting_odometry)
            lock = self.client.receive_data().decode()

            if lock != 'START':
                continue

            while True:

                # [linear x: float, angular z: float, delta t: float, complete: bool or int]
                
                x, z, dt, is_complete = ast.literal_eval(self.client.receive_data().decode().strip()) # instructions
                if is_complete: break

                ins_start_pos = self.odometry_msg_data_pos
                
                self.__publish_twist_message(x, z)
                time.sleep(dt)
                self.__publish_twist_message(0.0, 0.0)
                time.sleep(0.5) # allow for deceleration

                return_data = str(

                    {
                        'orientation': round(quart_funcs.adjust_orientation_origin(normalizing_quat,self.odometry_msg_data),precision),
                        'distance_traveled': round(compute_distance(self.odometry_msg_data_pos, ins_start_pos),precision)
                    }

                )

                self.client.send_data(return_data.encode())


    def reset_distance_and_radians(self):

        self.distance_traveled = 0.0
        self.radians_rotated = 0.0

    def odometer_callback(self,msg):

        if msg == None: return
        
        if not self.starting_odometry_set: 
            self.starting_odometry_set = True
        else:
            q = self.odometry_msg.pose.pose.position
            x, y, z = q.x, q.y, q.z # save the values before proceeding
            q = self.odometry_msg.pose.pose.orientation
            quart = (q.x,q.y,q.z,q.w)

        self.odometry_msg = msg
        self.odometry_msg_data = (
            msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w,
        )
        self.odometry_msg_data_pos = (
            msg.pose.pose.position.x,
            msg.pose.pose.position.y,
            msg.pose.pose.position.z
        )

        try:

            q = self.odometry_msg.pose.pose.position
            x1, y1, z1 = q.x, q.y, q.z # save the values before proceeding
            q = self.odometry_msg.pose.pose.orientation
            quart2 = (q.x,q.y,q.z,q.w)
            self.distance_traveled += math.sqrt((x1-x)**2 + (y1-y)**2 + (z1-z)**2)
            self.radians_rotated += round(abs(yaw_difference(quart2, quart)),4)
            # print((round(self.distance_traveled,2),round(self.radians_rotated * 180 / math.pi,2)))

        except Exception as e:
            print("Error encountered on odometer callback:")
            print(e)
            pass

    def print_log(self, mess:str):

        print(f"[AutoDataCollector: {time.ctime()}] " + mess)

    def __publish_twist_message(self, linear_x, angular_z):


        data = Twist()
        data.linear.x = linear_x
        data.angular.z = angular_z
        self.movement_publisher.publish(data)
        
        self.twist_timestamp = time.time()
        if self.last_twist_timestamp != None:
            print("Twist time delay:",self.twist_timestamp - self.last_twist_timestamp)
        self.last_twist_timestamp = self.twist_timestamp

        return

    def move_x_meters_feedback(self, distance, slowdown_threshold=0.4, vel_x:float = 0.2): # accurate, works up to +- 0.005 meters

        # implement here
        start = self.odometry_msg_data_pos
        self.distance_traveled = 0.0
        switch = True

        while distance - slowdown_threshold > self.distance_traveled:
            if switch:
                self.__publish_twist_message(vel_x,0.0)
                switch = False
        

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5)

        switch = True
        while distance > self.distance_traveled:
            if switch:
                self.__publish_twist_message(0.1,0.0)
                switch = False

        self.__publish_twist_message(0.0,0.0)
        
        time.sleep(0.5)
        end = self.odometry_msg_data_pos
        print("Distance error:",round(distance-compute_distance(start, end), 4))

        return distance-compute_distance(start, end)

    def rotate(self, angular_distance_radians, direction, slowdown_threshold = 0.4, angl_vel_z:float = 1.0):

        print("Direction:", direction)
        self.radians_rotated = 0.0
        starting = self.odometry_msg_data

        switch = True # this is done to get the min and max angular values
        while angular_distance_radians-slowdown_threshold > self.radians_rotated:

            if direction.lower() == "left":
                
                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=angl_vel_z)
            elif direction.lower() == "right":
                
                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=-angl_vel_z)
            else:
                print("ERROR: invalid direction")
                return
            time.sleep(0.1)

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5) # simulate inference

        switch = True
        while angular_distance_radians > self.radians_rotated:

            if direction.lower() == "left":

                if switch:
                    switch = False
                    self.__publish_twist_message(0.0, angular_z=0.2)
            elif direction.lower() == "right":

                if switch:
                    switch = False
                    self.__publish_twist_message(0.0,angular_z=-0.2)
            else:
                print("ERROR: invalid direction")
                return
            time.sleep(0.1)

        self.__publish_twist_message(0.0,0.0)
        time.sleep(0.5)

        ending = self.odometry_msg_data
        
        print(f"Rotated {direction} degrees [Internal]:",round(self.radians_rotated * 180 / math.pi,3))
        return round(self.radians_rotated * 180 / math.pi,3)
    
    def rotate_to_orientation(self, angle_in_radians: float, angl_vel_z: float = 1.5):
        
        desired = normalize_radians(angle_in_radians) # prevent unattainable cases
        current = normalize_radians(quaternion_to_yaw(*self.odometry_msg_data))

        delta = desired - current

        if math.isclose(delta,0,rel_tol=args.threshold_angular):
            return 
        
        elif delta > 0: # rotate left
    
            self.rotate(abs(delta), "left")

        else: # delta < 0

            self.rotate(abs(delta), "right")

def main(args=None, n_args=args):

    rclpy.init(args=args)

    sensors_subscriber = AutoDataCollector(comm_on=n_args.comm, sampler_on=n_args.sampler, debug=n_args.debug)
    rclpy.spin(sensors_subscriber)
    sensors_subscriber.destroy_node()

if __name__ == '__main__':

    main()